# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13-IFUuVtVUMDujNsJpxyoFcH--J-dwwe
"""

# Commented out IPython magic to ensure Python compatibility.
# # Ensure library versions and some other packages
# %%capture
# %pip install scipy==1.1.0
# %pip uninstall vis
# %pip install git+https://github.com/raghakot/keras-vis.git -U
# %pip install h5py==2.10.0 --force-reinstall

# Restart the Google Colab Runtime to apply the changes above
import os

def restart_runtime():
  os.kill(os.getpid(), 9)

# Commented out IPython magic to ensure Python compatibility.
# Switch to Tensorflow v1.
# %tensorflow_version 2.x

# Commented out IPython magic to ensure Python compatibility.


from keras import backend as K
from tensorflow.python.client import device_lib

import tensorflow as tf
tf.test.is_gpu_available()

# %matplotlib inline

import glob
import matplotlib
from matplotlib import pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import imageio as im
from skimage.io import imread
from skimage.transform import resize
from keras import models
from keras.models import Sequential
from keras.layers import Conv2D
from keras.layers import MaxPooling2D
from keras.layers import Flatten
from keras.layers import Dense
from keras.layers import Dropout
from keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ModelCheckpoint
import random
from time import time

classes = ['fire','grass','water']

path_to_train_set = 'drive/MyDrive/foto'
path_to_test_set = 'drive/MyDrive/destra'
path_to_sample = 'drive/MyDrive/destra/fire/2.jpg'

import math
def plot_training_set_images(class_to_plot, path_to_train_set):
    '''
    This function plots all the JPG and PNG images in the specified path
    '''
    images = []
    for img_path in glob.glob(f'{path_to_train_set}/{class_to_plot}/*.png') + glob.glob(f'{path_to_train_set}/{class_to_plot}/*.jpg'):
        images.append(mpimg.imread(img_path))

    plt.figure(figsize=(200, 100))
    columns = 5
    rows = math.ceil(len(images) / columns)  # Calcolo del numero di righe

    for i, image in enumerate(images):
        plt.subplot(rows, columns, i + 1)
        plt.imshow(image)


def plot_image_with_pixel_values(img, ax):
  '''
  This function displays an image and the grayscale for each pixel
  '''
  ax.imshow(img, cmap='gray')
  width, height = img.shape
  thresh = img.max() / 2.5
  for x in range(width):
      for y in range(height):
          ax.annotate(str(round(img[ x ][ y ], 2)), xy=(y, x),
                  horizontalalignment='center',
                  verticalalignment='center',
                  color='white' if img[ x ][ y ] < thresh else 'black')

def plot_image(path_to_image):
  '''
  This function displays an image resized to the height and width we will use for the model
  And also displays the pixel grayscale in a separate image
  '''
  # Load a color image in grayscale
  image = imread(path_to_image, as_gray=True)
  image = resize(image, (28, 28), mode='reflect')
  print('This image is: ', type(image),
        'with dimensions:', image.shape)
  plt.imshow(image, cmap='gray')

  fig = plt.figure(figsize=(12, 12))
  ax = fig.add_subplot(111)
  plot_image_with_pixel_values(image, ax)

def plot_model_learning(history):
  '''
  This function generates the plots to view the learning of the model through the epochs
  '''
  acc = history.history['accuracy']
  val_acc = history.history['val_accuracy']
  loss = history.history['loss']
  val_loss = history.history['val_loss']

  epochs = range(1, len(acc) + 1)

  plt.plot(epochs, acc, 'bo', label='Training accuracy')
  plt.plot(epochs, val_acc, 'b', label='Validation accuracy')
  plt.title('Training and validation accuracy')
  plt.legend()

  plt.figure()

  plt.plot(epochs, loss, 'bo', label='Training loss')
  plt.plot(epochs, val_loss, 'b', label='Validation loss')
  plt.title('Training and validation loss')
  plt.legend()

  plt.show()

def predict_new_image(classifier, classes, path_to_test_set):
    '''
    This function takes a random image from the test set and predicts its class using our trained classifier
    '''

    # Randomly choose from one of our classes
    random_class = random.choice(classes)

    # Select a random image from the class selected above
    random_test_image = random.choice(os.listdir(f'{path_to_test_set}/{random_class}/'))

    # Build the path for the random image
    img_path = f'{path_to_test_set}/{random_class}/{random_test_image}'

    # Load the image
    normalImage = image.load_img(img_path)

    img = image.load_img(img_path, target_size=(28, 28))
    img_tensor = image.img_to_array(img)
    img_tensor = np.expand_dims(img_tensor, axis=0)
    img_tensor /= 255.

    # Plot the image

    plt.imshow(normalImage)
    plt.show()

    plt.imshow(img_tensor[0])
    plt.show()

    # Predict the class probabilities of the image
    predictions = classifier.predict(img_tensor)[0]

    # Print the predicted probabilities for each class
    for class_name, probability in zip(classes, predictions):
        print(f"Probability for class {class_name}: {probability}")

    # Extract the predicted class
    predicted_class_index = np.argmax(predictions)
    predicted_class = classes[predicted_class_index]

    print(f"Tipo del pokemon predetto dal modello: {predicted_class}\nTipo reale del pokemon: {random_class}")
    if(predicted_class==random_class):
      print("Il modello ha indovinato!")

for i in range(len(classes)):
  print(f"Class {i}: {classes[i]}")
  plot_training_set_images(classes[i], path_to_train_set)
  print("")

# Example of 1 image
img = im.imread(path_to_sample, mode='L')  # o mode='L'
print(f"Image shape: {img.shape}")

plot_image(path_to_sample)

# Initialising the CNN
classifier = Sequential()

# Step 1 - Convolution
classifier.add(Conv2D(32, (3, 3), padding='valid', input_shape = (28, 28, 3), activation = 'relu'))
classifier.add(Conv2D(32, (3, 3), activation='relu'))
classifier.add(MaxPooling2D(pool_size=(2, 2)))
classifier.add(Dropout(0.5)) # before used 0.25

# # Adding a second convolutional layer
classifier.add(Conv2D(64, (3, 3), padding='valid', activation = 'relu'))
classifier.add(Conv2D(64, (3, 3), activation='relu'))
classifier.add(MaxPooling2D(pool_size=(2, 2)))
classifier.add(Dropout(0.5)) # before used 0.25

# # OPTIONAL: Adding a third convolutional layer
# classifier.add(Conv2D(64, (3, 3), padding='same', activation = 'relu'))
# classifier.add(Conv2D(64, (3, 3), activation='relu'))
# classifier.add(MaxPooling2D(pool_size=(2, 2)))
# classifier.add(Dropout(0.5)) # before used 0.25

# Step 3 - Flattening
classifier.add(Flatten())

# Step 4 - Full connection
classifier.add(Dense(units = 128, activation = 'relu'))
# classifier.add(Dense(units = 512, activation = 'relu')) # OPTIONAL
classifier.add(Dropout(0.5))
classifier.add(Dense(units = len(classes), activation = 'softmax', name='preds'))

classifier.summary()

# Compiling the CNN
classifier.compile(optimizer = 'rmsprop',
                   loss = 'categorical_crossentropy',
                   metrics = ['accuracy'])

train_datagen = ImageDataGenerator(rescale = 1./255)
test_datagen = ImageDataGenerator(rescale = 1./255)

training_set = train_datagen.flow_from_directory(path_to_train_set, target_size = (28, 28), batch_size = 16, class_mode = 'categorical')

test_set = test_datagen.flow_from_directory(path_to_test_set, target_size = (28, 28), batch_size = 16, class_mode = 'categorical')

from keras.callbacks import EarlyStopping
checkpointer = ModelCheckpoint(filepath="best_weights.hdf5",
                               monitor = 'val_accuracy',
                               verbose=1,
                               save_best_only=True)

earlystopping = EarlyStopping(monitor='val_accuracy',
                               patience=10,  # Numero di epoche senza miglioramenti prima di interrompere
                               restore_best_weights=True)

history = classifier.fit(training_set,
                         steps_per_epoch = 10,
                         epochs = 100,
                         callbacks=[checkpointer,earlystopping],
                         verbose = 1,
                         validation_data = test_set)

classifier.load_weights('best_weights.hdf5')

classifier.save('shapes_cnn.h5')

plot_model_learning(history)

predict_new_image(classifier, classes, path_to_test_set)